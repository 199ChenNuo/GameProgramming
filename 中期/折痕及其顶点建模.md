# Part2 折痕、折痕顶点建模、约束关系

项目代码：[mycode](https://github.com/changeyoung98/GPcode)

参照项目[OrigimaSimulator](https://github.com/amandaghassaei/OrigamiSimulator/tree/master/js)中的beam.js和node.js分别对折痕和折痕顶点进行建模。


## Node类
对应代码为node.h node.cpp

构造函数
```cpp
Node(Vector3 position, int index)
```

新建了一个Vector3类表三维向量，定义了对应的减操作、取模操作和距离操作。
```cpp
Vector3(float _x, float _y, float _z)
	:x(_x), y(_y), z(_z) {}
Vector3()
	:x(0.0f), y(0.0f),z(0.0f) {}
```

类中定义的各函数均对应node.js中的函数操作。

```cpp
bool operator==(Node node);
void addCrease(Crease crease);
bool removeCrease(Crease crease);
void addInvCrease(Crease crease);
bool removeInvCrease(Crease crease);

void addBeam(Beam beam);
bool removeBeam(Beam beam);
vector<Beam> & getBeams();
int numBeams();

Vector3 get_original_position();
void set_original_position(Vector3 v);
Vector3 getPosition();
void moveManually(Vector3 position);
Vector3 getRelativePosition();

void setFixed(bool fix);
bool isFixed();
bool isConnectedTo(Node node);
int getIndex();
float getSimMass();
```

### **后续扩展**
- 为了尽可能将接口全部实现，定义了一个Crease类和他的==操作。后续实现之后直接将class部分代码替换为头文件即可。
- 源代码中关于外部力的代码有些注释掉了，因此这部分关于external force的接口还没实现。
- 源代码中还出现了object3D相关的内容，也暂时没有实现。



## Beam类
对应代码为beam.h beam.cpp

构造函数
```cpp
Beam(pair<Node,Node> nodes)
```
类中定义的各函数均对应beam.js中的函数操作。
```cpp
	bool operator==(Beam beam);
	Node getOtherNode(Node node);
	float getLength();
	float getOriginalLength();
	void recalcOriginalLength();
	bool isFixed();
	Vector3 getVector(Node fromNode);
	float getK();
	float getD();
	float getNaturalFrequency();
	float getMinMass();
```

### **后续扩展**
- Beam部分的私有变量有一个nodes数组和一个vertices数组，由于一条beam只有两个顶点，所以在这部分我的处理是定义了两个pair，如需修改只要寻找含有first和second的代码即可。
- 代码中dynamic solve部分需要一个全局的global数组来记录折纸模型的各部分变化，这一部分不影响代码的整体结构，我在代码中注释了需要更新的部分。

In node.cpp
```cpp
Vector3 Node::getPosition()
{
	vector<float> positions;
	//TODO: get the collection of positions from global.model
	//positions=globals.model.getPositionsArray();
	return Vector3(positions[3 * index], positions[3 + index + 1], positions[3 * index + 2]);
}

void Node::moveManually(Vector3 position)
{
	vector<float> positions;
	//positions=globals.model.getPositionsArray();

	positions[3 * index] = position.x;
	positions[3 * index + 1] = position.y;
	positions[3 * index + 2] = position.z;
}
```
In beam.cpp
```cpp
float Beam::getK()
{
	//return globals.axialStiffness/getLength();
	return 0.0f;
}

float Beam::getD()
{
	//return globals.percentDamping*2*sqrt(getK()*getMinMass());
	return 0.0f;
}
```